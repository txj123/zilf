<?php

namespace Zilf\Helpers;

/**
 * Html provides a set of static methods for generating commonly used HTML tags.
 *
 * Nearly all of the methods in this class allow setting additional html attributes for the html
 * tags they generate. You can specify for example. 'class', 'style'  or 'id' for an html element
 * using the `$options` parameter. See the documentation of the [[tag()]] method for more details.
 */
class Html
{
    /**
     * @var array list of void elements (element name => 1)
     * @see http://www.w3.org/TR/html-markup/syntax.html#void-element
     */
    public static $voidElements = [
        'area' => 1,
        'base' => 1,
        'br' => 1,
        'col' => 1,
        'command' => 1,
        'embed' => 1,
        'hr' => 1,
        'img' => 1,
        'input' => 1,
        'keygen' => 1,
        'link' => 1,
        'meta' => 1,
        'param' => 1,
        'source' => 1,
        'track' => 1,
        'wbr' => 1,
    ];

    /**
     * @var array the preferred order of attributes in a tag. This mainly affects the order of the attributes
     * that are rendered by [[renderTagAttributes()]].
     */
    public static $attributeOrder = [
        'type',
        'id',
        'class',
        'name',
        'value',

        'href',
        'src',
        'action',
        'method',

        'selected',
        'checked',
        'readonly',
        'disabled',
        'multiple',

        'size',
        'maxlength',
        'width',
        'height',
        'rows',
        'cols',

        'alt',
        'title',
        'rel',
        'media',
    ];

    /**
     * @var array list of tag attributes that should be specially handled when their values are of array type.
     * In particular, if the value of the `data` attribute is `['name' => 'xyz', 'age' => 13]`, two attributes
     * will be generated instead of one: `data-name="xyz" data-age="13"`.
     * @since 2.0.3
     */
    public static $dataAttributes = ['data', 'data-ng', 'ng'];

    /**
     * Encodes special characters into HTML entities.
     * The [[\Zilf\Db\base\Application::charset|application charset]] will be used for encoding.
     *
     * @param  string  $content      the content to be encoded
     * @param  boolean $doubleEncode whether to encode HTML entities in `$content`. If false,
     *                               HTML entities in `$content` will not be further encoded.
     * @return string the encoded content
     * @see    decode()
     * @see    http://www.php.net/manual/en/function.htmlspecialchars.php
     */
    public static function encode($content, $doubleEncode = true)
    {
        return htmlspecialchars($content, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8', $doubleEncode);
    }

    /**
     * Decodes special HTML entities back to the corresponding characters.
     * This is the opposite of [[encode()]].
     *
     * @param  string $content the content to be decoded
     * @return string the decoded content
     * @see    encode()
     * @see    http://www.php.net/manual/en/function.htmlspecialchars-decode.php
     */
    public static function decode($content)
    {
        return htmlspecialchars_decode($content, ENT_QUOTES);
    }

    /**
     * Generates a complete HTML tag.
     *
     * @param string|boolean|null $name    the tag name. If $name is `null` or `false`, the corresponding content will be rendered without any tag.
     * @param string              $content the content to be enclosed between the start and end tags. It will not be HTML-encoded.
     *                                     If this is coming from end users, you should consider [[encode()]] it to prevent XSS
     *                                     attacks.
     * @param array               $options the HTML tag attributes (HTML options) in terms of name-value pairs.
     *                                     These will be rendered as the attributes of the resulting tag. The
     *                                     values will be HTML-encoded using [[encode()]]. If a value is null,
     *                                     the corresponding attribute will not be rendered. For example when
     *                                     using `['class' => 'my-class', 'target' => '_blank', 'value' =>
     *                                     null]` it will result in the html attributes rendered like this:
     *                                     `class="my-class" target="_blank"`. See [[renderTagAttributes()]]
     *                                     for details on how attributes are being rendered.
     *
     * @return string the generated HTML tag
     * @see    beginTag()
     * @see    endTag()
     */
    public static function tag($name, $content = '', $options = [])
    {
        if ($name === null || $name === false) {
            return $content;
        }
        $html = "<$name" . static::renderTagAttributes($options) . '>';
        return isset(static::$voidElements[strtolower($name)]) ? $html : "$html$content</$name>";
    }

    /**
     * Generates a link tag that refers to an external CSS file.
     *
     * @param  array|string $url     the URL of the external CSS file. This parameter will be processed by [[Url::assetUrl()]].
     * @param  array        $options the tag options in terms of name-value pairs. The following option is specially handled:
     *                               - condition: specifies the conditional comments for IE, e.g., `lt IE 9`. When this is
     *                               specified, the generated `link` tag will be enclosed within the conditional comments.
     *                               This is mainly useful for supporting old versions of IE browsers. - noscript: if set to
     *                               true, `link` tag will be wrapped into `<noscript>` tags. The rest of the options will be
     *                               rendered as the attributes of the resulting link tag. The values will be HTML-encoded
     *                               using [[encode()]]. If a value is null, the corresponding attribute will not be
     *                               rendered. See [[renderTagAttributes()]] for details on how attributes are being
     *                               rendered.
     * @param  string       $urlName
     * @return string the generated link tag
     * @see    Url::assetUrl()
     */
    public static function assetCss($url, $options = [], $urlName = 'default')
    {
        $html = '';
        if (is_array($url)) {
            foreach ($url as $item) {
                $html .= self::getCssHtml($item, $options, $urlName);
            }
        } else {
            $html = self::getCssHtml($url, $options, $urlName);
        }

        return $html;
    }

    /**
     * @param $url
     * @param array  $options
     * @param string $urlName
     * @return string
     */
    private static function getCssHtml($url, $options = [], $urlName = 'default')
    {
        if (!isset($options['rel'])) {
            $options['rel'] = 'stylesheet';
        }

        $version = $options['version'] ?? config('app.assets.css_version');
        unset($options['version']);
        $options['href'] = Url::assetUrl($url, $version, $urlName);
        unset($version);

        if (isset($options['condition'])) {
            $condition = $options['condition'];
            unset($options['condition']);
            $html = self::wrapIntoCondition(static::tag('link', '', $options), $condition);
        } elseif (isset($options['noscript']) && $options['noscript'] === true) {
            unset($options['noscript']);
            $html = '<noscript>' . static::tag('link', '', $options) . '</noscript>';
        } else {
            $html = static::tag('link', '', $options);
        }

        return $html;
    }

    /**
     * Generates a script tag that refers to an external JavaScript file.
     *
     * @param  string $url     the URL of the external JavaScript file. This parameter will be processed by [[Url::assetUrl()]].
     * @param  array  $options the tag options in terms of name-value pairs. The following option is specially handled:
     *                         - condition: specifies the conditional comments for IE, e.g., `lt IE 9`. When this is
     *                         specified, the generated `script` tag will be enclosed within the conditional comments.
     *                         This is mainly useful for supporting old versions of IE browsers. The rest of the
     *                         options will be rendered as the attributes of the resulting script tag. The values will
     *                         be HTML-encoded using [[encode()]]. If a value is null, the corresponding attribute will
     *                         not be rendered. See [[renderTagAttributes()]] for details on how attributes are being
     *                         rendered.
     * @param  string $urlName
     * @return string the generated script tag
     * @see    Url::assetUrl()
     */
    public static function assetJs($url, $options = [], $urlName = 'default')
    {
        $html = '';
        if (is_array($url)) {
            foreach ($url as $item) {
                $html .= self::getJsHtml($item, $options, $urlName);
            }
        } else {
            $html = self::getJsHtml($url, $options, $urlName);
        }

        return $html;
    }

    /**
     * @param $url
     * @param $options
     * @param $urlName
     * @return string
     */
    private static function getJsHtml($url, $options, $urlName= 'default')
    {
        $version = $options['version'] ?? config('app.assets.js_version');
        unset($options['version']);
        $options['src'] = Url::assetUrl($url, $version, $urlName);
        unset($version);
        if (isset($options['condition'])) {
            $condition = $options['condition'];
            unset($options['condition']);
            return self::wrapIntoCondition(static::tag('script', '', $options), $condition);
        } else {
            return static::tag('script', '', $options);
        }
    }

    /**
     * Generates a hyperlink tag.
     *
     * @param string            $text    link body. It will NOT be HTML-encoded. Therefore you can pass in HTML code
     *                                   such as an image tag. If this is coming from end users, you should consider
     *                                   [[encode()]] it to prevent XSS attacks.
     * @param array|string|null $url     the URL for the hyperlink tag. This parameter will be processed by [[Url::toRoute()]]
     *                                   and will be used for the "href" attribute of the tag. If this parameter is null, the
     *                                   "href" attribute will not be generated. If you want to use an absolute url you can
     *                                   call [[Url::assetUrl()]] yourself, before passing the URL to this method, like this:
     *                                   ```php Html::a('link text', Url::toRoute($url, true)) ```
     *
     * @param  array             $options the tag options in terms of name-value pairs. These will be rendered as
     *                                    the attributes of the resulting tag. The values will be HTML-encoded
     *                                    using [[encode()]]. If a value is null, the corresponding attribute
     *                                    will not be rendered. See [[renderTagAttributes()]] for details on how
     *                                    attributes are being rendered.
     * @return string the generated hyperlink
     * @see    \Zilf\Helpers\Url::toRoute()
     */
    public static function a($text, $url = null, $options = [])
    {
        if ($url !== null) {
            $options['href'] = Url::toRoute($url);
        }
        return static::tag('a', $text, $options);
    }

    /**
     * Generates a mailto hyperlink.
     *
     * @param  string $text    link body. It will NOT be HTML-encoded. Therefore you can pass in HTML code
     *                         such as an image tag. If this is coming from end users, you should consider
     *                         [[encode()]] it to prevent XSS attacks.
     * @param  string $email   email address. If this is null, the first parameter (link body) will be treated
     *                         as the email address and used.
     * @param  array  $options the tag options in terms of name-value pairs. These will be rendered as
     *                         the attributes of the resulting tag. The values will be HTML-encoded
     *                         using [[encode()]]. If a value is null, the corresponding attribute
     *                         will not be rendered. See [[renderTagAttributes()]] for details on how
     *                         attributes are being rendered.
     * @return string the generated mailto link
     */
    public static function mailto($text, $email = null, $options = [])
    {
        $options['href'] = 'mailto:' . ($email === null ? $text : $email);
        return static::tag('a', $text, $options);
    }

    /**
     * Generates an image tag.
     *
     * @param  array|string $src     the image URL. This parameter will be processed by [[Url::toRoute()]].
     * @param  array        $options the tag options in terms of name-value pairs. These will be rendered as
     *                               the attributes of the resulting tag. The values will be HTML-encoded
     *                               using [[encode()]]. If a value is null, the corresponding attribute
     *                               will not be rendered. See [[renderTagAttributes()]] for details on how
     *                               attributes are being rendered.
     * @param  string       $urlName
     * @return string the generated image tag
     */
    public static function assetImg($src, $options = [], $urlName= 'default')
    {
        $html = '';
        if (is_array($src)) {
            foreach ($src as $item) {
                $html .= self::getImgHtml($item, $options, $urlName);
            }
        } else {
            $html = self::getImgHtml($src, $options, $urlName);
        }

        return $html;
    }

    /**
     * @param $src
     * @param array  $options
     * @param string $urlName
     * @return string
     */
    private static function getImgHtml($src, $options = [],$urlName= 'default')
    {
        $version = $options['version'] ?? config('app.assets.css_version');
        unset($options['version']);
        $options['src'] = Url::assetUrl($src, $version, $urlName);
        if (!isset($options['alt'])) {
            $options['alt'] = '';
        }
        return static::tag('img', '', $options);
    }

    /**
     * Renders the HTML tag attributes.
     *
     * Attributes whose values are of boolean type will be treated as
     * [boolean attributes](http://www.w3.org/TR/html5/infrastructure.html#boolean-attributes).
     *
     * Attributes whose values are null will not be rendered.
     *
     * The values of attributes will be HTML-encoded using [[encode()]].
     *
     * The "data" attribute is specially handled when it is receiving an array value. In this case,
     * the array will be "expanded" and a list data attributes will be rendered. For example,
     * if `'data' => ['id' => 1, 'name' => 'Zilf']`, then this will be rendered:
     * `data-id="1" data-name="Zilf"`.
     * Additionally `'data' => ['params' => ['id' => 1, 'name' => 'Zilf'], 'status' => 'ok']` will be rendered as:
     * `data-params='{"id":1,"name":"Zilf"}' data-status="ok"`.
     *
     * @param  array $attributes attributes to be rendered. The attribute values will be HTML-encoded using [[encode()]].
     * @return string the rendering result. If the attributes are not empty, they will be rendered
     * into a string with a leading white space (so that it can be directly appended to the tag name
     * in a tag. If there is no attribute, an empty string will be returned.
     */
    public static function renderTagAttributes($attributes)
    {
        if (count($attributes) > 1) {
            $sorted = [];
            foreach (static::$attributeOrder as $name) {
                if (isset($attributes[$name])) {
                    $sorted[$name] = $attributes[$name];
                }
            }
            $attributes = array_merge($sorted, $attributes);
        }

        $html = '';
        foreach ($attributes as $name => $value) {
            if (is_bool($value)) {
                if ($value) {
                    $html .= " $name";
                }
            } elseif (is_array($value)) {
                if (in_array($name, static::$dataAttributes)) {
                    foreach ($value as $n => $v) {
                        if (is_array($v)) {
                            $html .= " $name-$n='" . Json::htmlEncode($v) . "'";
                        } else {
                            $html .= " $name-$n=\"" . static::encode($v) . '"';
                        }
                    }
                } elseif ($name === 'class') {
                    if (empty($value)) {
                        continue;
                    }
                    $html .= " $name=\"" . static::encode(implode(' ', $value)) . '"';
                } elseif ($name === 'style') {
                    if (empty($value)) {
                        continue;
                    }
                    $html .= " $name=\"" . static::encode(static::cssStyleFromArray($value)) . '"';
                } else {
                    $html .= " $name='" . Json::htmlEncode($value) . "'";
                }
            } elseif ($value !== null) {
                $html .= " $name=\"" . static::encode($value) . '"';
            }
        }

        return $html;
    }

    /**
     * Wraps given content into conditional comments for IE, e.g., `lt IE 9`.
     *
     * @param  string $content   raw HTML content.
     * @param  string $condition condition string.
     * @return string generated HTML.
     */
    private static function wrapIntoCondition($content, $condition)
    {
        if (strpos($condition, '!IE') !== false) {
            return "<!--[if $condition]><!-->\n" . $content . "\n<!--<![endif]-->";
        }
        return "<!--[if $condition]>\n" . $content . "\n<![endif]-->";
    }

    /**
     * Converts a CSS style array into a string representation.
     *
     * For example,
     *
     * ```php
     * print_r(Html::cssStyleFromArray(['width' => '100px', 'height' => '200px']));
     * // will display: 'width: 100px; height: 200px;'
     * ```
     *
     * @param  array $style the CSS style array. The array keys are the CSS property names,
     *                      and the array values are the corresponding CSS property values.
     * @return string the CSS style string. If the CSS style is empty, a null will be returned.
     */
    public static function cssStyleFromArray(array $style)
    {
        $result = '';
        foreach ($style as $name => $value) {
            $result .= "$name: $value; ";
        }
        // return null if empty to avoid rendering the "style" attribute
        return $result === '' ? null : rtrim($result);
    }
}
